<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Topk问题</title>
    <link href="/2021/04/07/topk%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/07/topk%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="TopK问题"><a href="#TopK问题" class="headerlink" title="TopK问题"></a>TopK问题</h1><p>Topk问题是在面试中常出现的一个问题，在这里也翻车过几次，特在这里总结一下。</p><p>该问题是指在大量数据中找到最大的k个数（或者是第k大的数），一般来说可以用小顶堆或者快速排序来解决</p><h2 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 对前k个元素建成小根堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-built_in">swim</span>(nums, i);<br>        &#125;<br>        <span class="hljs-comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br>                <span class="hljs-built_in">sink</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 结束后第k个大的数就是小根堆的堆顶</span><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>   <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 若v1比v2优先度高，返回true</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">priorityThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123; <span class="hljs-keyword">return</span> v1 &lt; v2; &#125;<br><br>    <span class="hljs-comment">// 上浮 从下到上调整堆</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heap, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">priorityThan</span>(heap[i], heap[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])) &#123;<br>            <span class="hljs-built_in">swap</span>(heap[i], heap[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]);<br>            i = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 下沉 从下到上调整堆</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heap, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= N) &#123;<br>            <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= N &amp;&amp; <span class="hljs-built_in">priorityThan</span>(heap[j + <span class="hljs-number">1</span>], heap[j])) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">priorityThan</span>(heap[i], heap[j])) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(heap[i], heap[j]);<br>            i = j;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> i=l+<span class="hljs-number">1</span>,j=r;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<span class="hljs-keyword">while</span>(i&lt;r&amp;&amp;nums[i]&lt;=nums[l])<br>        &#123;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l&lt;j&amp;&amp;nums[j]&gt;=nums[l])<br>        &#123;<br>            --j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&gt;=j)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[l],nums[j]);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, target = nums.<span class="hljs-built_in">size</span>() - k; <br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid=<span class="hljs-built_in">quicksort</span>(nums,l,r);<br>            <span class="hljs-keyword">if</span>(mid==target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> nums[mid];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid&lt;target)<br>            &#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021春招面试</title>
    <link href="/2021/04/02/2021%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/04/02/2021%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-腾讯魔方工作室一面（约50mins）"><a href="#4-1-腾讯魔方工作室一面（约50mins）" class="headerlink" title="4-1 腾讯魔方工作室一面（约50mins）"></a>4-1 腾讯魔方工作室一面（约50mins）</h2><p>人生中第一次面试，在31号晚上写完网易笔试收到的消息，然后就开始了紧张的复习，当天早上和下午的课完全没心思听，一直在刷c++基础知识和做算法题。</p><p>晚上八点面试，然而我和面试官都提早上线就比较早开始了，自我介绍太紧张了一开口说错自己是大二的了，面试官人很好，按着我的回答引导下去提问，到不会的地方就转移知识点了。</p><p>c++一些地方则是完全没复习到，难以想象居然连类继承权限都忘了……我都要被自己蠢哭了，然后常量指针和指针常量没区分好，排序算法没解释完全，设计模式只说了概念。</p><p>计网讲了tcp、udp，五层协议，检查tcp包的完整性。</p><p>最后十分钟算法题，emmm，脑子空白没写出来，结束之后发现自己已经写得七七八八了，代码能力有待提高。</p><p>面完第二天下午就挂了，是自己表现太菜了，感觉浪费了别人的时间。</p><h2 id="4-9-网易互娱游戏研发面试（1-5h）"><a href="#4-9-网易互娱游戏研发面试（1-5h）" class="headerlink" title="4-9 网易互娱游戏研发面试（1.5h）"></a>4-9 网易互娱游戏研发面试（1.5h）</h2><p>主要结合简历来问，在沟通的过程中一直深挖。</p><p>1.上来一道算法题，本人做题慢热型没做完，leetcode1129 安排会议</p><p>看了题解发现很简单，但…….完全没想到。</p><p>2.c++部分</p><p>智能指针：<strong>shared_ptr的实现机制</strong></p><p>讲讲三个特点：封装继承多态</p><p>c有没有重载</p><p>虚函数：</p><p>（1）基类指针指向子类对象，<strong>基类构造函数调用虚函数，析构函数调用虚函数，分别调用的是基类还是子类的函数。</strong></p><p>（2）虚函数指针vptr的存放位置</p><p><strong>定义一个空类，它的对象的空间大小是多少。</strong></p><p>说说const转换</p><p>3.操作系统</p><p>进程线程的区别</p><p>cpu调度算法</p><p>如何激活一个线程</p><p>4.计网</p><p>tcp/udp区别</p><p>tcp拥塞控制</p><p>tcp四次挥手</p><p>题目10亿个ipv4地址，找出访问最多次的地址。</p><p>聊项目相关</p><p>反问：实习生应该提前做什么准备，答：基础要好，不同工作室课题很广，好基础才能解决（有着暗示我基础不行的感觉，凉了）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img src="E:\nodejs\blog\source\img\sort.png" alt="算法复杂度"></p><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span> (l + <span class="hljs-number">1</span> &gt;= r) <br>  &#123; <span class="hljs-keyword">return</span>; &#125; <br>  <span class="hljs-keyword">int</span> first = l, last = r - <span class="hljs-number">1</span>, key = nums[first]; <br>  <span class="hljs-keyword">while</span> (first &lt; last)&#123; <br>      <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key) <br>      &#123; --last; &#125; <br>      nums[first] = nums[last]; <br>      <span class="hljs-keyword">while</span> (first &lt; last &amp;&amp; nums[first] &lt;= key) <br>      &#123; ++first; &#125; <br>      nums[last] = nums[first]; <br>  &#125; <br>  nums[first] = key; <br>  <span class="hljs-built_in">quick_sort</span>(nums, l, first); <br>  <span class="hljs-built_in">quick_sort</span>(nums, first + <span class="hljs-number">1</span>, r); <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;temp)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span> (l + <span class="hljs-number">1</span> &gt;= r) <br>  &#123; <span class="hljs-keyword">return</span>; &#125; <span class="hljs-comment">// divide int m = l + (r - l) / 2; </span><br>  <span class="hljs-built_in">merge_sort</span>(nums, l, m, temp);<br>  <span class="hljs-built_in">merge_sort</span>(nums, m, r, temp); <span class="hljs-comment">// conquer </span><br>  <span class="hljs-keyword">int</span> p = l, q = m, i = l; <br>  <span class="hljs-keyword">while</span> (p &lt; m || q &lt; r) <br>  &#123; <span class="hljs-keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) <br>    &#123; <br>      temp[i++] = nums[p++]; &#125; <br>      <span class="hljs-keyword">else</span> &#123; <br>        temp[i++] = nums[q++]; <br>      &#125; <br>    &#125; <br>    <span class="hljs-keyword">for</span> (i = l; i &lt; r; ++i) &#123; <br>       nums[i] = temp[i]; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[j]&lt;nums[j<span class="hljs-number">-1</span>];--j)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[j],nums[j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>   &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i;++j)<br>      &#123;<br>        <span class="hljs-keyword">if</span>(nums[j]&gt;nums[j+<span class="hljs-number">1</span>])<br>        &#123;<br>           <span class="hljs-built_in">swap</span>(nums[j],nums[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.选择排序"></a>5.选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)<br>    &#123;<br>        mid=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[j]&lt;nums[mid])<br>            &#123;<br>                mid=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[mid],nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现多态</title>
    <link href="/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/"/>
    <url>/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言实现多态"><a href="#C语言实现多态" class="headerlink" title="C语言实现多态"></a>C语言实现多态</h1><p><a href="https://blog.csdn.net/wenqiang1208/article/details/76244628">原文</a></p><h2 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1.C++和C的区别"></a>1.C++和C的区别</h2><p>C语言是面向过程的语言，而C++是面向对象的过程。</p><h3 id="什么是面向对象和面向过程？"><a href="#什么是面向对象和面向过程？" class="headerlink" title="什么是面向对象和面向过程？"></a>什么是面向对象和面向过程？</h3><p>面向过程就是分析解决问题的步骤，然后用函数把这些步骤一步一步的进行实现，在使用的时候进行一一调用就行了，注重的是对于过程的分析。面向对象则是把构成问题的事进行分成各个对象，建立对象的目的也不仅仅是完成这一个个步骤，而是描述各个问题在解决的过程中所发生的行为。</p><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>面向过程的设计方法采用函数来描述数据的操作，但将函数与操作的数据进行分离开来。<br>面向对象的设计方法是将对象和数据进行封装起来成为一个整体。<br>面向过程以设计步骤为过程，后期难以维护。<br>面向对象设计以数据为中心，数据相对与功能来说具有较强的稳定性更加易于维护。</p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>封装：<br>对于封装来说就是数据与具体操作实现的代码都放在某个对象的内部，使这些代码的具体细节不被外界发现，只留下一些接口供外部来使用，而不能一任何的形式来对象内部的实现。使用封装能够隐藏具体的实现的细节，使代码更加易于维护并且保证了系统的安全性。<br>继承：<br>继承机制是面向对象程序设计使代码进行复用的最重要的手段，他允许程序员在保证类原有类特性的基础上进行扩展来增加功能。这样新产生的类就被称为派生类，继承就可以表现面向对象机制的的层次结构。<br>多态：<br>多态简单点说就是“一个接口，多种实现”，就是同一种事物表现出的多种形态。多态在面向对象语言中是指：接口多种的不同实现方式。也就是复用相同接口，实现不同操作。</p><p>C++多态支持两种多态性，<strong>编译时多态</strong>和<strong>运行时多态</strong>。编译时多态是通过重载函数来实现的，运行时多态是通过虚函数来实现的。静态多态：编译器在编译期间完成，编译器根据函数实参的类型（可能会隐式类型转换），可推断出要调用哪个函数，如果有对应的函数就调用相应的函数，否则就报一个编译错误。动态多态：在函数执行期间（非编译期）判断所引用对象的实际类型，根据实际类型的调用相应的方法。使用virtual关键字修饰类的成员函数，指明该函数为虚函数，派生类需要重新实现，编译器将实现动态绑定。</p><h2 id="2-C模拟实现多态"><a href="#2-C模拟实现多态" class="headerlink" title="2.C模拟实现多态"></a>2.C模拟实现多态</h2><p>关于c++如何实现多态可参考上篇文章</p><p>我们知道在C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；但是在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//C实现动态，用到函数指针</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*FUN)</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//重定义一个函数指针类型</span><br><br><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> </span><br><span class="hljs-class">&#123;</span><br>    FUN _f;<br>&#125;;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span></span><br><span class="hljs-class">&#123;</span><br>    Base _b;<span class="hljs-comment">//在子类中定义一个基类的对象即可实现对父类的继承</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Base::fun()&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunD</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Derived::fun()&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<span class="hljs-comment">//父类对象</span><br>    Derived d;<span class="hljs-comment">//子类对象</span><br><br>    b._f = FunB;<span class="hljs-comment">//父类对象调用父类同名函数</span><br>    d._b._f = FunD;<span class="hljs-comment">//子类调用子类的同名函数</span><br><br>    Base *pb = &amp;b;<span class="hljs-comment">//父类指针指向父类对象</span><br>    pb-&gt;_f();<br><br>    pb = (Base *)&amp;d;<span class="hljs-comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br>    pb-&gt;_f();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识复习</title>
    <link href="/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"><a href="#1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源" class="headerlink" title="1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"></a>1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？<a href="https://blog.csdn.net/gochenguowei/article/details/79682681?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">来源</a></h2><h3 id="构造函数为什么不能是虚函数呢？"><a href="#构造函数为什么不能是虚函数呢？" class="headerlink" title="构造函数为什么不能是虚函数呢？"></a>构造函数为什么不能是虚函数呢？</h3><p>    首先需要了解 vptr指针和虚函数表的概念，以及这两者的关联。</p><p>​    vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。</p><p>​    当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。</p><h3 id="基类的析构函数为什么必须是虚函数呢？"><a href="#基类的析构函数为什么必须是虚函数呢？" class="headerlink" title="基类的析构函数为什么必须是虚函数呢？"></a>基类的析构函数为什么必须是虚函数呢？</h3><p>    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。</p><p>​    那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base时，会调用析构函数为我们释放资源。而 我们执行BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放BaseClass 基类申请的资源，而不是释放SubClass派生类的资源。原因如下：</p><p>​    基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。</p><p>​    当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。    </p><p>    因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。</p><h2 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h2><p>重载：指同一可访问区域内被声明的几个具有不同参数列的同名函数，使用时根据参数列表确定调用哪个函数，重载不关心函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i, <span class="hljs-keyword">int</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;         <span class="hljs-comment">//错误，非重载</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>重写：即覆盖，指在派生类中存在重新定义的函数。其函数名、参数列表和返回类型同基类中被重写的函数一致，只有函数体不同。重写的基类中被重写的函数必须有virual修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;A::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;B::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _b;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-多态的实现及原理"><a href="#3-多态的实现及原理" class="headerlink" title="3.多态的实现及原理"></a>3.<a href="https://blog.csdn.net/qikaihuting/article/details/78433996?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">多态的实现及原理</a></h2><p>C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用晚绑定，当编译器使用晚绑定时候，就会在运行时再去确定对象的类型以及正确的调用函数，而要让编译器采用晚绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。</p><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>编译器在编译的时候，发现Father类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址。</p><p><img src="http://images2015.cnblogs.com/blog/1019006/201611/1019006-20161117144006873-661542828.png" alt="img"></p><p>那么如何定位虚表呢？编译器另外还为每个对象提供了一个虚表指针(即vptr)，这个指针指向了对象所属类的虚表，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数，对于第二段代码程序，由于pFather实际指向的对象类型是Son，因此vptr指向的Son类的vtable，当调用pFather-&gt;Son()时，根据虚表中的函数地址找到的就是Son类的Say()函数，且续表在构造函数初始化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　1:每一个类都有虚表</p><p>　　2:虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果基类有3个虚函数，那么基类的虚表中就有三项(虚函数地址)，派生类也会虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。</p><p>　　3：派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p><p>　　这就是c++中的多态性，当c++编译器在编译的时候，发现Father类的Say()函数是虚函数，这个时候c++就会采用晚绑定技术，也就是编译时并不确定具体调用的函数，而是在运行时，依据对象的类型来确认调用的是哪一个函数，这种能力就叫做c++的多态性，我们没有在Say()函数前加virtual关键字时，c++编译器就确定了哪个函数被调用，这叫做早期绑定。</p><p>　　c++的多态性就是通过晚绑定技术来实现的。</p><p>　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><h2 id="3-new-delete与malloc-free的区别与联系？"><a href="#3-new-delete与malloc-free的区别与联系？" class="headerlink" title="3.new/delete与malloc/free的区别与联系？"></a>3.new/delete与malloc/free的区别与联系？</h2><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><h4 id="分配失败"><a href="#分配失败" class="headerlink" title="分配失败"></a>分配失败</h4><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p><p> malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p><h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p><h2 id="4-模板声明与定义要放在同一文件中？"><a href="#4-模板声明与定义要放在同一文件中？" class="headerlink" title="4.模板声明与定义要放在同一文件中？"></a>4.模板声明与定义要放在同一文件中？</h2><p>“通常情况下，你会在.h文件中声明函数和类，而将它们的定义放置在一个单独的.cpp文件中。但是在使用模板时，这种习惯性做法将变得不再有用，因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因。”[1]</p><p>“标准要求编译器在实例化模板时必须在上下文中可以查看到其定义实体；而反过来，在看到实例化模板之前，编译器对模板的定义体是不处理的——原因很简单，编译器怎么会预先知道 typename 实参是什么呢？因此模板的实例化与定义体必须放到同一翻译单元中。”</p><h2 id="5-四种cast转换"><a href="#5-四种cast转换" class="headerlink" title="5.四种cast转换"></a>5.四种cast转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>1、const_cast</p><p>用于将const变量转为非const</p><p>2、static_cast</p><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><p>3、dynamic_cast</p><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。<em><strong>只能转指针或引用</strong></em>。向下转化时，如果是非法的<em><strong>对于指针返回NULL，对于引用抛异常</strong></em>。要深入了解内部转换的原理。</p><p>向上转换：指的是子类向基类的转换</p><p>向下转换：指的是基类向子类的转换</p><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><p>4、reinterpret_cast</p><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p><h2 id="6-const-char-、char-const-、-char-const-三者的区别"><a href="#6-const-char-、char-const-、-char-const-三者的区别" class="headerlink" title="6.const char * 、char const *、 char * const 三者的区别"></a>6.const char * 、char const *、 char * const 三者的区别</h2><p>前两者都是指向char类型常量的指针，第三者是指向char类型的指针常数</p><h2 id="7-C-普通函数，普通成员函数、静态成员函数的区别"><a href="#7-C-普通函数，普通成员函数、静态成员函数的区别" class="headerlink" title="7.C++普通函数，普通成员函数、静态成员函数的区别"></a>7.C++普通函数，普通成员函数、静态成员函数的区别</h2><p>普通函数：属于全局函数，不受具体类和对象的限制，可以直接调用。</p><p>普通成员函数：C++ 普通成员函数本质上是一个包含指向具体对象this指针的普通函数，即c++类的普通成员函数都隐式包含一个指向当前对象的this指针。</p><p>静态成员函数</p><p>首先介绍类的静态成员变量： 类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。</p><p>静态成员变量的性质：</p><p>1）static型变量只被初始化一次，下次执行初始化语句会直接跳过。</p><p>2）static 说明一个类的成员为静态成员，经过static修饰的成员变量属于这个类，不再仅仅属于具体的对象。</p><p>再介绍静态成员函数： 类体中的成员函数的声明前加上static关键字，该成员函数就成为了该类的静态成员函数。</p><p>静态成员函数的性质：</p><p>1）不可以调用类的非静态成员。</p><p>2）静态成员函数不含this指针。 静态成员函数属于这个类，不再仅仅属于具体的对象。</p><p>因此类的静态成员函数和类的普通成员函数的区别是：</p><p>静态成员函数不包含指向具体对象的this指针；</p><p>普通成员函数包含一个指向具体对象的this指针。</p><h2 id="8-传值传引用传指针"><a href="#8-传值传引用传指针" class="headerlink" title="8.传值传引用传指针"></a>8.传值传引用传指针</h2><p><strong>参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。</strong></p><p>（1）传入的实参实际上是a和b的副本而非其本身，所以对副本的改变并不会反应到a和b本身上。</p><p>（2）传入的实参实际上是a和b的引用，对引用的改变会直接反应到a和b本身上。</p><p>（3）传入的实参实际上是a和b的指针的副本，而且改变的是副本本身（其间接引用），不会（会）影响的指针所指向的值，即a和b本身上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">(<span class="hljs-number">3</span>)两种情况<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> *temp = x ;<br><br>x = y ;<br><br>y = temp ;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> temp = *x ;<br><br>*x = *y ;<br><br>*y = temp ;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-C-堆栈-内存四区"><a href="#9-C-堆栈-内存四区" class="headerlink" title="9.C++堆栈 内存四区"></a>9.C++堆栈 内存四区</h2><p><img src="https://images2015.cnblogs.com/blog/686215/201512/686215-20151217212304818-35561961.png" alt="内存四区"></p><h3 id="（1）代码区"><a href="#（1）代码区" class="headerlink" title="（1）代码区"></a>（1）代码区</h3><p>程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。</p><h3 id="（2）静态区"><a href="#（2）静态区" class="headerlink" title="（2）静态区"></a>（2）静态区</h3><p>静态区存放程序中所有的全局变量和静态变量。</p><h3 id="（3）栈区"><a href="#（3）栈区" class="headerlink" title="（3）栈区"></a>（3）栈区</h3><p>栈（stack）是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。</p><ul><li><p>每个线程都有自己专属的栈；</p></li><li><p>栈的最大尺寸固定，超出则引起栈溢出；</p></li><li><p>变量离开作用域后栈上的内存会自动释放。</p><p><img src="https://images2015.cnblogs.com/blog/686215/201512/686215-20151215210556552-208228469.png" alt="栈的存储"></p></li></ul><h3 id="（4）堆区"><a href="#（4）堆区" class="headerlink" title="（4）堆区"></a>（4）堆区</h3><p>　堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决上面实验三造成的内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制）。那堆内存如何使用？</p><h2 id="10-引用和指针的区别"><a href="#10-引用和指针的区别" class="headerlink" title="10.引用和指针的区别"></a>10.引用和指针的区别</h2><p>指针和引用都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。<br>程序为指针变量分配内存区域，而不为引用分配内存区域。</p><p>1.指针使用时要在前加 * ，引用可以直接使用。</p><p>2.引用在定义时就被初始化，之后无法改变；指针可以发生改变。 即引用的对象不能改变，指针的对象可以改变。</p><p>3.没有空引用，但有空指针。这使得使用引用的代码效率比使用指针的更高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。</p><p>4.对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。</p><p>5.理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。<br>int **p //合法<br>int &amp;&amp;p //非法</p><p>6.++引用与++指针的效果不一样。<br>例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
