<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021春招面试</title>
    <link href="/2021/04/02/2021%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/04/02/2021%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-腾讯魔方工作室一面（约50mins）"><a href="#4-1-腾讯魔方工作室一面（约50mins）" class="headerlink" title="4-1 腾讯魔方工作室一面（约50mins）"></a>4-1 腾讯魔方工作室一面（约50mins）</h2><p>人生中第一次面试，在31号晚上写完网易笔试收到的消息，然后就开始了紧张的复习，当天早上和下午的课完全没心思听，一直在刷c++基础知识和做算法题。</p><p>晚上八点面试，然而我和面试官都提早上线就比较早开始了，自我介绍太紧张了一开口说错自己是大二的了，面试官人很好，按着我的回答引导下去提问，到不会的地方就转移知识点了。</p><p>c++一些地方则是完全没复习到，难以想象居然连类继承权限都忘了……我都要被自己蠢哭了，然后常量指针和指针常量没区分好，排序算法没解释完全，设计模式只说了概念。</p><p>计网讲了tcp、udp，五层协议，检查tcp包的完整性。</p><p>最后十分钟算法题，emmm，脑子空白没写出来，结束之后发现自己已经写得七七八八了，代码能力有待提高。</p><p>面完第二天下午就挂了，是自己表现太菜了，感觉浪费了别人的时间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法知识点</title>
    <link href="/2021/03/31/%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/31/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法知识点"><a href="#算法知识点" class="headerlink" title="算法知识点"></a>算法知识点</h1><h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span> (l + <span class="hljs-number">1</span> &gt;= r) <br>  &#123; <span class="hljs-keyword">return</span>; &#125; <br>  <span class="hljs-keyword">int</span> first = l, last = r - <span class="hljs-number">1</span>, key = nums[first]; <br>  <span class="hljs-keyword">while</span> (first &lt; last)&#123; <br>      <span class="hljs-keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key) <br>      &#123; --last; &#125; <br>      nums[first] = nums[last]; <br>      <span class="hljs-keyword">while</span> (first &lt; last &amp;&amp; nums[first] &lt;= key) <br>      &#123; ++first; &#125; <br>      nums[last] = nums[first]; <br>  &#125; <br>  nums[first] = key; <br>  <span class="hljs-built_in">quick_sort</span>(nums, l, first); <br>  <span class="hljs-built_in">quick_sort</span>(nums, first + <span class="hljs-number">1</span>, r); <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现多态</title>
    <link href="/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/"/>
    <url>/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言实现多态"><a href="#C语言实现多态" class="headerlink" title="C语言实现多态"></a>C语言实现多态</h1><p><a href="https://blog.csdn.net/wenqiang1208/article/details/76244628">原文</a></p><h2 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1.C++和C的区别"></a>1.C++和C的区别</h2><p>C语言是面向过程的语言，而C++是面向对象的过程。</p><h3 id="什么是面向对象和面向过程？"><a href="#什么是面向对象和面向过程？" class="headerlink" title="什么是面向对象和面向过程？"></a>什么是面向对象和面向过程？</h3><p>面向过程就是分析解决问题的步骤，然后用函数把这些步骤一步一步的进行实现，在使用的时候进行一一调用就行了，注重的是对于过程的分析。面向对象则是把构成问题的事进行分成各个对象，建立对象的目的也不仅仅是完成这一个个步骤，而是描述各个问题在解决的过程中所发生的行为。</p><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>面向过程的设计方法采用函数来描述数据的操作，但将函数与操作的数据进行分离开来。<br>面向对象的设计方法是将对象和数据进行封装起来成为一个整体。<br>面向过程以设计步骤为过程，后期难以维护。<br>面向对象设计以数据为中心，数据相对与功能来说具有较强的稳定性更加易于维护。</p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>封装：<br>对于封装来说就是数据与具体操作实现的代码都放在某个对象的内部，使这些代码的具体细节不被外界发现，只留下一些接口供外部来使用，而不能一任何的形式来对象内部的实现。使用封装能够隐藏具体的实现的细节，使代码更加易于维护并且保证了系统的安全性。<br>继承：<br>继承机制是面向对象程序设计使代码进行复用的最重要的手段，他允许程序员在保证类原有类特性的基础上进行扩展来增加功能。这样新产生的类就被称为派生类，继承就可以表现面向对象机制的的层次结构。<br>多态：<br>多态简单点说就是“一个接口，多种实现”，就是同一种事物表现出的多种形态。多态在面向对象语言中是指：接口多种的不同实现方式。也就是复用相同接口，实现不同操作。</p><p>C++多态支持两种多态性，<strong>编译时多态</strong>和<strong>运行时多态</strong>。编译时多态是通过重载函数来实现的，运行时多态是通过虚函数来实现的。静态多态：编译器在编译期间完成，编译器根据函数实参的类型（可能会隐式类型转换），可推断出要调用哪个函数，如果有对应的函数就调用相应的函数，否则就报一个编译错误。动态多态：在函数执行期间（非编译期）判断所引用对象的实际类型，根据实际类型的调用相应的方法。使用virtual关键字修饰类的成员函数，指明该函数为虚函数，派生类需要重新实现，编译器将实现动态绑定。</p><h2 id="2-C模拟实现多态"><a href="#2-C模拟实现多态" class="headerlink" title="2.C模拟实现多态"></a>2.C模拟实现多态</h2><p>关于c++如何实现多态可参考上篇文章</p><p>我们知道在C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；但是在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//C实现动态，用到函数指针</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*FUN)</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//重定义一个函数指针类型</span><br><br><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> </span><br><span class="hljs-class">&#123;</span><br>    FUN _f;<br>&#125;;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span></span><br><span class="hljs-class">&#123;</span><br>    Base _b;<span class="hljs-comment">//在子类中定义一个基类的对象即可实现对父类的继承</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Base::fun()&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunD</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Derived::fun()&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<span class="hljs-comment">//父类对象</span><br>    Derived d;<span class="hljs-comment">//子类对象</span><br><br>    b._f = FunB;<span class="hljs-comment">//父类对象调用父类同名函数</span><br>    d._b._f = FunD;<span class="hljs-comment">//子类调用子类的同名函数</span><br><br>    Base *pb = &amp;b;<span class="hljs-comment">//父类指针指向父类对象</span><br>    pb-&gt;_f();<br><br>    pb = (Base *)&amp;d;<span class="hljs-comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br>    pb-&gt;_f();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识复习</title>
    <link href="/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"><a href="#1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源" class="headerlink" title="1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"></a>1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？<a href="https://blog.csdn.net/gochenguowei/article/details/79682681?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">来源</a></h2><h3 id="构造函数为什么不能是虚函数呢？"><a href="#构造函数为什么不能是虚函数呢？" class="headerlink" title="构造函数为什么不能是虚函数呢？"></a>构造函数为什么不能是虚函数呢？</h3><p>    首先需要了解 vptr指针和虚函数表的概念，以及这两者的关联。</p><p>​    vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。</p><p>​    当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。</p><h3 id="基类的析构函数为什么必须是虚函数呢？"><a href="#基类的析构函数为什么必须是虚函数呢？" class="headerlink" title="基类的析构函数为什么必须是虚函数呢？"></a>基类的析构函数为什么必须是虚函数呢？</h3><p>    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。</p><p>​    那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base时，会调用析构函数为我们释放资源。而 我们执行BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放BaseClass 基类申请的资源，而不是释放SubClass派生类的资源。原因如下：</p><p>​    基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。</p><p>​    当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。    </p><p>    因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。</p><h2 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h2><p>重载：指同一可访问区域内被声明的几个具有不同参数列的同名函数，使用时根据参数列表确定调用哪个函数，重载不关心函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i, <span class="hljs-keyword">int</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;         <span class="hljs-comment">//错误，非重载</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>重写：即覆盖，指在派生类中存在重新定义的函数。其函数名、参数列表和返回类型同基类中被重写的函数一致，只有函数体不同。重写的基类中被重写的函数必须有virual修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;A::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;B::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _b;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-多态的实现及原理"><a href="#3-多态的实现及原理" class="headerlink" title="3.多态的实现及原理"></a>3.<a href="https://blog.csdn.net/qikaihuting/article/details/78433996?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">多态的实现及原理</a></h2><p>C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用晚绑定，当编译器使用晚绑定时候，就会在运行时再去确定对象的类型以及正确的调用函数，而要让编译器采用晚绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。</p><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>编译器在编译的时候，发现Father类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址。</p><p><img src="http://images2015.cnblogs.com/blog/1019006/201611/1019006-20161117144006873-661542828.png" alt="img"></p><p>那么如何定位虚表呢？编译器另外还为每个对象提供了一个虚表指针(即vptr)，这个指针指向了对象所属类的虚表，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数，对于第二段代码程序，由于pFather实际指向的对象类型是Son，因此vptr指向的Son类的vtable，当调用pFather-&gt;Son()时，根据虚表中的函数地址找到的就是Son类的Say()函数，且续表在构造函数初始化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　1:每一个类都有虚表</p><p>　　2:虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果基类有3个虚函数，那么基类的虚表中就有三项(虚函数地址)，派生类也会虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。</p><p>　　3：派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p><p>　　这就是c++中的多态性，当c++编译器在编译的时候，发现Father类的Say()函数是虚函数，这个时候c++就会采用晚绑定技术，也就是编译时并不确定具体调用的函数，而是在运行时，依据对象的类型来确认调用的是哪一个函数，这种能力就叫做c++的多态性，我们没有在Say()函数前加virtual关键字时，c++编译器就确定了哪个函数被调用，这叫做早期绑定。</p><p>　　c++的多态性就是通过晚绑定技术来实现的。</p><p>　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><h2 id="3-new-delete与malloc-free的区别与联系？"><a href="#3-new-delete与malloc-free的区别与联系？" class="headerlink" title="3.new/delete与malloc/free的区别与联系？"></a>3.new/delete与malloc/free的区别与联系？</h2><p>[]: <a href="https://blog.csdn.net/changyi9995/article/details/108250671?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/changyi9995/article/details/108250671?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242</a></p><p>（1）malloc开辟空间类型大小需手动计算，new是由编译器自己计算；<br>（2）malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针；<br>（3）malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；</p><p>（4）无论释放几个空间大小，free只传递指针，多个对象时delete需加[]（原因在第3）；</p><h2 id="4-模板声明与定义要放在同一文件中？"><a href="#4-模板声明与定义要放在同一文件中？" class="headerlink" title="4.模板声明与定义要放在同一文件中？"></a>4.模板声明与定义要放在同一文件中？</h2><p>“通常情况下，你会在.h文件中声明函数和类，而将它们的定义放置在一个单独的.cpp文件中。但是在使用模板时，这种习惯性做法将变得不再有用，因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因。”[1]</p><p>“标准要求编译器在实例化模板时必须在上下文中可以查看到其定义实体；而反过来，在看到实例化模板之前，编译器对模板的定义体是不处理的——原因很简单，编译器怎么会预先知道 typename 实参是什么呢？因此模板的实例化与定义体必须放到同一翻译单元中。”</p><h2 id="5-四种cast转换"><a href="#5-四种cast转换" class="headerlink" title="5.四种cast转换"></a>5.四种cast转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>1、const_cast</p><p>用于将const变量转为非const</p><p>2、static_cast</p><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><p>3、dynamic_cast</p><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。<em><strong>只能转指针或引用</strong></em>。向下转化时，如果是非法的<em><strong>对于指针返回NULL，对于引用抛异常</strong></em>。要深入了解内部转换的原理。</p><p>向上转换：指的是子类向基类的转换</p><p>向下转换：指的是基类向子类的转换</p><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><p>4、reinterpret_cast</p><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p><h2 id="6-const-char-、char-const-、-char-const-三者的区别"><a href="#6-const-char-、char-const-、-char-const-三者的区别" class="headerlink" title="6.const char * 、char const *、 char * const 三者的区别"></a>6.const char * 、char const *、 char * const 三者的区别</h2><p>前两者都是指向char类型常量的指针，第三者是指向char类型的指针常数</p><h2 id="7-C-普通函数，普通成员函数、静态成员函数的区别"><a href="#7-C-普通函数，普通成员函数、静态成员函数的区别" class="headerlink" title="7.C++普通函数，普通成员函数、静态成员函数的区别"></a>7.C++普通函数，普通成员函数、静态成员函数的区别</h2><p>普通函数：属于全局函数，不受具体类和对象的限制，可以直接调用。</p><p>普通成员函数：C++ 普通成员函数本质上是一个包含指向具体对象this指针的普通函数，即c++类的普通成员函数都隐式包含一个指向当前对象的this指针。</p><p>静态成员函数</p><p>首先介绍类的静态成员变量： 类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。</p><p>静态成员变量的性质：</p><p>1）static型变量只被初始化一次，下次执行初始化语句会直接跳过。</p><p>2）static 说明一个类的成员为静态成员，经过static修饰的成员变量属于这个类，不再仅仅属于具体的对象。</p><p>再介绍静态成员函数： 类体中的成员函数的声明前加上static关键字，该成员函数就成为了该类的静态成员函数。</p><p>静态成员函数的性质：</p><p>1）不可以调用类的非静态成员。</p><p>2）静态成员函数不含this指针。 静态成员函数属于这个类，不再仅仅属于具体的对象。</p><p>因此类的静态成员函数和类的普通成员函数的区别是：</p><p>静态成员函数不包含指向具体对象的this指针；</p><p>普通成员函数包含一个指向具体对象的this指针。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
