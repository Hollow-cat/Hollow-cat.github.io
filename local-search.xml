<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言实现多态</title>
    <link href="/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/"/>
    <url>/2021/03/30/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言实现多态"><a href="#C语言实现多态" class="headerlink" title="C语言实现多态"></a>C语言实现多态</h1><p><a href="https://blog.csdn.net/wenqiang1208/article/details/76244628">原文</a></p><h2 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1.C++和C的区别"></a>1.C++和C的区别</h2><p>C语言是面向过程的语言，而C++是面向对象的过程。</p><h3 id="什么是面向对象和面向过程？"><a href="#什么是面向对象和面向过程？" class="headerlink" title="什么是面向对象和面向过程？"></a>什么是面向对象和面向过程？</h3><p>面向过程就是分析解决问题的步骤，然后用函数把这些步骤一步一步的进行实现，在使用的时候进行一一调用就行了，注重的是对于过程的分析。面向对象则是把构成问题的事进行分成各个对象，建立对象的目的也不仅仅是完成这一个个步骤，而是描述各个问题在解决的过程中所发生的行为。</p><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>面向过程的设计方法采用函数来描述数据的操作，但将函数与操作的数据进行分离开来。<br>面向对象的设计方法是将对象和数据进行封装起来成为一个整体。<br>面向过程以设计步骤为过程，后期难以维护。<br>面向对象设计以数据为中心，数据相对与功能来说具有较强的稳定性更加易于维护。</p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>封装：<br>对于封装来说就是数据与具体操作实现的代码都放在某个对象的内部，使这些代码的具体细节不被外界发现，只留下一些接口供外部来使用，而不能一任何的形式来对象内部的实现。使用封装能够隐藏具体的实现的细节，使代码更加易于维护并且保证了系统的安全性。<br>继承：<br>继承机制是面向对象程序设计使代码进行复用的最重要的手段，他允许程序员在保证类原有类特性的基础上进行扩展来增加功能。这样新产生的类就被称为派生类，继承就可以表现面向对象机制的的层次结构。<br>多态：<br>多态简单点说就是“一个接口，多种实现”，就是同一种事物表现出的多种形态。多态在面向对象语言中是指：接口多种的不同实现方式。也就是复用相同接口，实现不同操作。</p><p>C++多态支持两种多态性，<strong>编译时多态</strong>和<strong>运行时多态</strong>。编译时多态是通过重载函数来实现的，运行时多态是通过虚函数来实现的。静态多态：编译器在编译期间完成，编译器根据函数实参的类型（可能会隐式类型转换），可推断出要调用哪个函数，如果有对应的函数就调用相应的函数，否则就报一个编译错误。动态多态：在函数执行期间（非编译期）判断所引用对象的实际类型，根据实际类型的调用相应的方法。使用virtual关键字修饰类的成员函数，指明该函数为虚函数，派生类需要重新实现，编译器将实现动态绑定。</p><h2 id="2-C模拟实现多态"><a href="#2-C模拟实现多态" class="headerlink" title="2.C模拟实现多态"></a>2.C模拟实现多态</h2><p>关于c++如何实现多态可参考上篇文章</p><p>我们知道在C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；但是在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//C实现动态，用到函数指针</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*FUN)</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//重定义一个函数指针类型</span><br><br><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> </span><br><span class="hljs-class">&#123;</span><br>    FUN _f;<br>&#125;;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span></span><br><span class="hljs-class">&#123;</span><br>    Base _b;<span class="hljs-comment">//在子类中定义一个基类的对象即可实现对父类的继承</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Base::fun()&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FunD</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Derived::fun()&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<span class="hljs-comment">//父类对象</span><br>    Derived d;<span class="hljs-comment">//子类对象</span><br><br>    b._f = FunB;<span class="hljs-comment">//父类对象调用父类同名函数</span><br>    d._b._f = FunD;<span class="hljs-comment">//子类调用子类的同名函数</span><br><br>    Base *pb = &amp;b;<span class="hljs-comment">//父类指针指向父类对象</span><br>    pb-&gt;_f();<br><br>    pb = (Base *)&amp;d;<span class="hljs-comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br>    pb-&gt;_f();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识复习</title>
    <link href="/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/03/24/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"><a href="#1-c-的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源" class="headerlink" title="1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？来源"></a>1.c++的构造函数为什么不能是虚函数，而基类的析构函数必须是虚函数？<a href="https://blog.csdn.net/gochenguowei/article/details/79682681?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">来源</a></h2><h3 id="构造函数为什么不能是虚函数呢？"><a href="#构造函数为什么不能是虚函数呢？" class="headerlink" title="构造函数为什么不能是虚函数呢？"></a>构造函数为什么不能是虚函数呢？</h3><p>    首先需要了解 vptr指针和虚函数表的概念，以及这两者的关联。</p><p>​    vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。</p><p>​    当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。</p><h3 id="基类的析构函数为什么必须是虚函数呢？"><a href="#基类的析构函数为什么必须是虚函数呢？" class="headerlink" title="基类的析构函数为什么必须是虚函数呢？"></a>基类的析构函数为什么必须是虚函数呢？</h3><p>    我们都知道，想要回收一个对象申请的资源，那么就需要调用析构函数。虽然我们没有显示地调用析构函数，但是编译器都会默认地为我们执行析构函数。</p><p>​    那么当我们执行 BaseClass *base = new BaseClass(); 当我们执行 delete base时，会调用析构函数为我们释放资源。而 我们执行BaseClass *sub = new SubClass(); 如果BaseClass基类的析构函数不是虚函数的时候，delete sub 对象的时候，只会释放BaseClass 基类申请的资源，而不是释放SubClass派生类的资源。原因如下：</p><p>​    基类指针指向了派生类对象，而基类中的析构函数是非virtual的，而虚构函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete的时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。</p><p>​    当然，如果在派生类中没有动态申请有资源的时候，是不会造成内存泄漏的。而当派生类对象的析构函数中有内存需要回收，并且在编程过程中采用了基类指针指向派生类对象，如为了实现多态，并且通过基类指针将对象销毁，这时，就会因为基类的析构函数为非虚函数而不触发动态绑定，从而没有调用派生类的析构函数而导致内存泄漏。    </p><p>    因此，为了防止这种情况下的内存泄漏的发生，最后将基类的析构函数写成virtual虚析构函数。</p><h2 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h2><p>重载：指同一可访问区域内被声明的几个具有不同参数列的同名函数，使用时根据参数列表确定调用哪个函数，重载不关心函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i, <span class="hljs-keyword">int</span> j)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;         <span class="hljs-comment">//错误，非重载</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>重写：即覆盖，指在派生类中存在重新定义的函数。其函数名、参数列表和返回类型同基类中被重写的函数一致，只有函数体不同。重写的基类中被重写的函数必须有virual修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;A::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;B::func1()&quot;</span> &lt;&lt; endl;<br>      &#125;<br><span class="hljs-keyword">private</span> :<br>       <span class="hljs-keyword">int</span> _b;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-多态的实现及原理"><a href="#3-多态的实现及原理" class="headerlink" title="3.多态的实现及原理"></a>3.<a href="https://blog.csdn.net/qikaihuting/article/details/78433996?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">多态的实现及原理</a></h2><p>C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用晚绑定，当编译器使用晚绑定时候，就会在运行时再去确定对象的类型以及正确的调用函数，而要让编译器采用晚绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。</p><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>编译器在编译的时候，发现Father类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址。</p><p><img src="http://images2015.cnblogs.com/blog/1019006/201611/1019006-20161117144006873-661542828.png" alt="img"></p><p>那么如何定位虚表呢？编译器另外还为每个对象提供了一个虚表指针(即vptr)，这个指针指向了对象所属类的虚表，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数，对于第二段代码程序，由于pFather实际指向的对象类型是Son，因此vptr指向的Son类的vtable，当调用pFather-&gt;Son()时，根据虚表中的函数地址找到的就是Son类的Say()函数，且续表在构造函数初始化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　1:每一个类都有虚表</p><p>　　2:虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果基类有3个虚函数，那么基类的虚表中就有三项(虚函数地址)，派生类也会虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。</p><p>　　3：派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p><p>　　这就是c++中的多态性，当c++编译器在编译的时候，发现Father类的Say()函数是虚函数，这个时候c++就会采用晚绑定技术，也就是编译时并不确定具体调用的函数，而是在运行时，依据对象的类型来确认调用的是哪一个函数，这种能力就叫做c++的多态性，我们没有在Say()函数前加virtual关键字时，c++编译器就确定了哪个函数被调用，这叫做早期绑定。</p><p>　　c++的多态性就是通过晚绑定技术来实现的。</p><p>　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><h1 id="3-new-delete与malloc-free的区别与联系？"><a href="#3-new-delete与malloc-free的区别与联系？" class="headerlink" title="3.new/delete与malloc/free的区别与联系？"></a>3.new/delete与malloc/free的区别与联系？</h1><p>[]: <a href="https://blog.csdn.net/changyi9995/article/details/108250671?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/changyi9995/article/details/108250671?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242</a></p><p>（1）malloc开辟空间类型大小需手动计算，new是由编译器自己计算；<br>（2）malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针；<br>（3）malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；</p><p>（4）无论释放几个空间大小，free只传递指针，多个对象时delete需加[]（原因在第3）；</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
